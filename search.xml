<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[中文词向量总结]]></title>
    <url>%2Funcategorized%2F%E4%B8%AD%E6%96%87%E8%AF%8D%E5%90%91%E9%87%8F%E6%80%BB%E7%BB%93</url>
    <content type="text"><![CDATA[中文词向量总结词向量基础知识 one-hot编码：假设我们的词库总共有n个词，那我们开一个1*n的高维向量，而每个词都会在某个索引index下取到1，其余位置全部都取值为0.词向量在这种类型的编码中如下图所示： 这种词向量编码方式简单粗暴，我们将每一个词作为一个完全独立的个体来表达。遗憾的是，这种方式下，我们的词向量没办法给我们任何形式的词组相似性权衡（任何两个one-hot向量内积都为0），而且每个词向量都高维稀疏,高维稀疏会造成维度灾难,计算复杂,存储量大等问题 基于SVD的方法：首先会遍历所有的文本数据集，然后统计词出现的次数，接着用一个矩阵$X$来表示所有的次数情况，紧接着对X进行奇异值分解得到一个$USV^T$的分解。然后用$U$的行（rows）作为所有词表中词的词向量,其中矩阵$X$的构建可以采用基于窗口的共现矩阵或者词-文档矩阵。基于SVD的方法能够充分地编码语义和句法的信息，但同时也带来了其他的问题： 矩阵的维度会经常变化（新的词语经常会增加，语料库的大小也会随时变化）。 矩阵是非常稀疏的，因为大多数词并不同时出现。 矩阵的维度通常非常高（≈$10^6*10^6$） 训练需要$O(n^2)$的复杂度（比如SVD） 需要专门对矩阵X进行特殊处理，以应对词组频率的极度不平衡的状况 基于迭代的方法：我们并不计算和存储全局信息，因为这会包含太多大型数据集和数十亿句子。我们尝试创建一个模型，它能够一步步迭代地进行学习，并最终得出每个单词基于其上下文的条件概率。在每次迭代过程中，这个模型都能够评估其误差，并按照一定的更新规则，惩罚那些导致误差的参数 连续词袋模型（CBOM） 有种模型是以{“The”, “cat”, ’over”, “the’, “puddle”}为上下文，能够预测或产生它们中心的词语”jumped”，叫做连续词袋模型,模型如图所示： 模型的运作方式如下： 对于m个词长度的输入上下文，我们产生它们的one-hot向量 我们得到上下文的嵌入词向量 将这些向量取平均 产生一个得分向量 $z=U\hat{v}$ 将得分向量转换成概率分布形式$\hat{y}=softmax(z)$ 我们希望我们产生的概率分布 ,与真实概率分布$y$相匹配。而刚好也就是我们期望$y$的真实词语的one-hot向量 利用交叉熵做为损失函数，最小化损失函数更新权重 要注意我们实际上对于每个词语$w_i$学习了两个向量。（作为输入词的向量$v_i$，和作为输出词的向量$u_j$） Skip-Gram 模型 跟上面提到的模型对应的另一种思路，是以中心的词语”jumped”为输入，能够预测或产生它周围的词语”The”, “cat”, ’over”, “the”, “puddle”等。这里我们叫”jumped”为上下文。我们把它叫做Skip-Gram 模型。 这个模型的建立与连续词袋模型（CBOM）非常相似，但本质上是交换了输入和输出的位置。我们令输入的one-hot向量（中心词）为x（因为它只有一个），输出向量为y(j)。U和V的定义与连续词袋模型一样，模型如图所示： 模型的运行方式如下： 生成one-hot输入向量x。 得到上下文的嵌入词向量$v_c=Vx$。 因为这里不需要取平均值的操作，所以直接是$\hat{v}=v_c$。 通过$u=Uv_c$产生2m个得分向量。 将得分向量转换成概率分布形式$y=softmax(u)$。 我们希望我们产生的概率分布与真实概率分布相匹配，也就是我们真实输出结果的one-hot向量。 利用交叉熵做为损失函数，最小化损失函数更新权重 负面抽样（Negative Sampling） 思路对比: Softmax：所有词(类别)当成单个词(类别)处理(有V个分类) H-softmax ：部分词(类别)当成负类处理(二叉树遍历时非叶子节点负例对应的子孙叶子节点)(有logV个分类) 负采样： 正类当成单个处理，非正类的词(类别)当成负类处理,为了减少计算量,负类里面做抽样)(有2个分类) 相同点: 负采样和h-softmax一样，采用LR做节点上的分类 两个问题: 1个正例和neg个负例如何做LR? 如何进行负采样? word2vec采样的方法并不复杂，如果词汇表的大小为]$V$那么我们就将一段长度为1的线段分成$V$份，每份对应词汇表中的一个词。当然每个词对应的线段长度是不一样的，高频词对应的线段长，低频词对应的线段短。每个词$w$的线段长度由下式决定 : 取3/4的原因：抑制太高频的词, 提升太低频的词 层次softmax 目的: 解决softmax每次训练更新都需要对所有预测类别(词)做指数计算,计算量过大的问题 实现: 采用霍夫曼编码根据类别(词)出现频率构建二叉树 二叉树的叶子节点是要预测的类别(词) 非叶子节点可以当做是神经网络的神经元,每个节点都有对应的输入和参数 为何能节省计算(以中心词w2为例): Softmax(需要计算O1、O2…Ov做指数计算,复杂度O(V) h-softmax(最大似然w2出现的概率,只要计算root-w2路径上的概率乘积,复杂度O(logV)词向量训练 层次softmax只是在训练的时候可以减少计算，在预测的时候，因为事先并不知道真实的输出分类，还是要计算所有输出，得到概率最大的输出 使用gensim训练词向量 gensim介绍:一款开源的第三方Python工具包，支持包括TF-IDF，LSA，LDA，和word2vec等算法接口 gensim安装:gensim安装要注意，gensim包依赖numpy和scipy包，可以去官网看gensim包依赖的最低numpy和scipy版本，然后pip install gensim,最简单的方式就是先安装anaconda,然后安装gensim，而且也要注意版本，具体可以参考 gensim安装，如果安装成功，from gensim.models import word2vec不会报错 gensim训练词向量步骤: 数据来源:资讯新闻数据(hive 表 t_sd_safe_news_source_kb),通过命令: 1hive -e &quot;select content_html from t_sd_safe_news_source_kb where ds = 20180815 and category1 = &apos;ent&apos; &quot; &gt; news_ent_content_html.txt 注意编码问题(通过这种方式导入的编码方式是GBK编码,可以通过python脚本将编码方式转换为utf-8,方便以后的计算),得到的文本格式如下: 一行代表一条html格式的资讯 数据预处理:提取正文,中文分词,参考代码/data/ceph_ai/devinkuang/code/Preprocessing.py,代码支持并行化分词(LTP+NER),处理html文件,去除停止词,去除标点. 注意: 训练词向量的时候不需要去除停止词和标点,因为词向量的训练是根据窗口共现的方式,停止词和标点也是句子成分的一部分 对原始数据预处理会出现很多问题,例如原始数据出现utf-8不能编码的字符;一条资讯内部出现换行符(会导致html解析错误);资讯全是图片,解析后没有文字等 使用opencc-python繁体转简体、jieba中文分词 可以opencc-python包，或者直接下载exe执行文件，使用命令opencc -i wiki-zh-article.txt -o wiki-zh-article-zhs.txt -c t2s.json接下来就是做分词，比较好用的工具有结巴分词、中科院的ICTCLAS、清华的THULAC、复旦的FudanNLP等。我选用了结巴 问题：之前是在代码里面使用opencc-python繁体转简体（而且是按照空格对文章切分之后，一个一个转换）发现速度很慢，后来选择使用exe执行文件，执行速度很快 处理后,得到如下格式的文本: 使用gensim提供的接口实现Word2vec训练: 12345678910111213import multiprocessingfrom gensim.models import Word2Vecfrom gensim.models.word2vec import LineSentence# LineSentence(source, max_sentence_length=10000, limit=None)inp = 'news_ent_content.txt' # 训练数据,一行一条资讯outp1 = 'news-ent-cbow-model' # 保存模型的参数和词向量outp2 = 'news-ent-cbow-vector' # 保存词向量的结果model = Word2Vec(LineSentence(inp), size = 400, window = 5, min_count = 5, workers = multiprocessing.cpu_count()) ## 参数都是按照常用的参数model.save(outp1) ## 以二进制格式存储model.save_word2vec_format(outp2, binary = False) ## 以文本格式存储， 一行是一个词的vector 词向量有很多参数,如下: 1234567891011121314151617181920211) sentences: 我们要分析的语料，可以是一个列表，或者从文件中遍历读出。后面我们会有从文件读出的例子。2) size: 词向量的维度，默认值是100。这个维度的取值一般与我们的语料的大小相关，如果是不大的语料，比如小于100M的文本语料，则使用默认值一般就可以了。如果是超大的语料，建议增大维度。size对词向量的影响很大,如果维度特别低或特别高，精度就会比较低 低维度词向量无法捕捉文集中不同词语的不同意义。这可以视为我们模型复杂度过低而导致的高偏差。比如 “king”, “queen”, “man”, “woman” 这几个词，我们需要至少2个维度像”gender” 如 “leadership” 来把它们编译成 2-字节 词向量。 过低的维度将无法捕捉四个词之间的语义差别，而过高的维度将捕捉到一些对泛化能力没有用的噪音– 即高方差的问题3) window：即词向量上下文最大距离，这个参数在我们的算法原理篇中标记为c，window越大，则和某一词较远的词也会产生上下文关系。默认值为5。在实际使用中，可以根据实际的需求来动态调整这个window的大小。如果是小语料则这个值可以设的更小。对于一般的语料这个值推荐在[5,10]之间。Skip-gram通常选择10左右，CBOW通常选择5左右(从博客上看到的，尚未找到理由，所以别信)4) sg: 即我们的word2vec两个模型的选择了。如果是0， 则是CBOW模型，是1,则是Skip-Gram模型，默认是0即CBOW模型。5) hs: 即我们的word2vec两个解法的选择了，如果是0， 则是Negative Sampling，是1的话并且负采样个数negative大于0， 则是Hierarchical Softmax。默认是0即Negative Sampling。6) negative:即使用Negative Sampling时负采样的个数，默认是5。推荐在[3,10]之间。这个参数在我们的算法原理篇中标记为neg。论文中设置的参数是107) cbow_mean: 仅用于CBOW在做投影的时候，为0，则算法中的xw为上下文的词向量之和，为1则为上下文的词向量的平均值。在我们的原理篇中，是按照词向量的平均值来描述的。个人比较喜欢用平均值来表示xw,默认值也是1,不推荐修改默认值。8) min_count:需要计算词向量的最小词频。这个值可以去掉一些很生僻的低频词，默认是5。如果是小语料，可以调低这个值。这个值的设定也可以过滤一些分词错误的词9) iter: 随机梯度下降法中迭代的最大次数，默认是5。对于大语料，可以增大这个值。10) alpha: 在随机梯度下降法中迭代的初始步长。算法原理篇中标记为η，默认是0.025。11) min_alpha: 由于算法支持在迭代的过程中逐渐减小步长，min_alpha给出了最小的迭代步长值。随机梯度下降中每轮的迭代步长可以由iter，alpha， min_alpha一起得出。这部分由于不是word2vec算法的核心内容，因此在原理篇我们没有提到。对于大语料，需要对alpha, min_alpha,iter一起调参，来选择合适的三个值。 参数的设置,一是设置经验参数,二是通过词向量评估的方法评估词向量,然后调整参数 词向量训练完成后,会得到四个文件: 我们可以通过gensim提供的方法对词向量训练出来的结果进行测试,常见的包括类比推理和相似性测试,测试链接:word2vec_ent测试,展示一些结果: 词向量的增量训练:gensim中word2vec提供增量训练的方式,如果有新加的词汇,可以在原有的模型上继续训练,具体如下: 12345678# 增量训练model = gensim.models.Word2Vec.load(temp_path) # 加载原来的模型more_sentences = [['Advanced', 'users', 'can', 'load', 'a', 'model', 'and', 'continue', 'training', 'it', 'with', 'more', 'sentences']] # 需要增量学习的语料model.build_vocab(more_sentences, update=True) # 对词表的词汇更新model.train(more_sentences, total_examples=model.corpus_count, epochs=model.iter) # 增量学习'''train(sentences, total_examples=None, total_words=None, epochs=None, start_alpha=None, end_alpha=None, word_count=0, queue_factor=2, report_delay=1.0, compute_loss=False, callbacks=())''' 所有相关的代码,数据和模型在mqq@100.65.21.223: /data/ceph_ai/devinkuang目录下 数据: 模型: 代码: 词向量评价 内部任务评价 外部任务评价是对在实际任务中产生的词向量进行的评价。这些任务通常是很复杂的，且它们的计算过程比较缓慢。在我们前面使用的例子中，允许基于问题对答案进行评估的系统是一种外部任务评价系统。一般来讲， 优化外部评价系统的时候我们无从知晓是哪个子系统除了问题，所以需要进一步进行内部任务评价 ,常见方法: 词聚类：可以采用 kmeans 聚类，看聚类簇的分布 词cos 相关性：查找cos相近的词 Analogy对比：a:b 与 c:d的cos距离 (man-king woman-queen ) 使用tnse，pca等降维可视化展示：词的分布，推荐用google的tensorboard，可以多视角查看，如果不想搭建服务，直接访问这里。另外可以用python的matplotlib 外部任务评价 外部任务评价是对在实际任务中产生的词向量进行的评价。这些任务通常是很复杂的，且它们的计算过程比较缓慢。在我们前面使用的例子中，允许基于问题对答案进行评估的系统是一种外部任务评价系统。一般来讲， 优化外部评价系统的时候我们无从知晓是哪个子系统出了问题，所以需要进一步进行内部任务评价 对外在性任务进行训练 重训练词向量 先初始化一个词向量,然后根据外部具体的任务对词向量进行fine-tune(TextCNN中的no-static就用了这个方法),不过，重训练词向量是由风险的,如果要在外部任务上重新训练词向量，我们需要保证训练集的大小足够覆盖词库中的大多数单词。因为Word2Vec或GloVe 生成的语义相关的词会在词空间中落在同一部分位置。如果我们用一个比较小的训练集去重训练，这些词在词空间中的位置就会发生变化，在最终任务上的精确度反而可能降低 ,因此，如果训练集较小，则最好不要重训练词向量。如果训练集很大，重训练也许能够提升精度 词向量内部评价实践 评测数据集: CA-translated数据集:其中大多数类比问题直接从英语基准中翻译得到 ,在很多中文词嵌入的论文被广泛应用 CA8:CA8 是专门为中文语言设计的。它包含了 17813 个类比问题，覆盖了综合的词法和语义关联 semantic.txt: morphological.txt: 下载地址和详情https://github.com/Embedding/Chinese-Word-Vectors/tree/master/testsets 测评代码在/data/ceph_ai/devinkuang/evaluate_word2vec/evaluation,运行: 12$ python ana_eval_dense.py -v &lt;vector.txt&gt; -a CA8/morphological.txt$ python ana_eval_dense.py -v &lt;vector.txt&gt; -a CA8/semantic.txt 既可以对自己得到的词向量文件vector.txt测试效果,下面我测试一下用维基百科数据训练Word2vec的测试结果,参数: 1model = Word2Vec(LineSentence(rawdata), size=400, window=5, min_count=5, workers=multiprocessing.cpu_count()) 以上结果据目前最好的结果还有不小的差距 通过测评我们会发现,影响词向量的主要有一下几个因素: 语料的影响: 不同的语料训练的词向量的结果差别很大,比如,我用娱乐类资讯的结果,查看苹果的top10相似词: 而用所以得资讯训练的结果如下: 词向量存在的一个最大的问题是,同样的词只有一种词向量的表达方式,不能处理多义性,Huang等人（2012）在论文《Improving Word Representations Via Global Context And Multiple Word Prototypes》中描述了如何在自然语言处理中解决上面提到的问题。他们提出的方法本质在于以下几点 针对目标单词出现的所有位置，收集固定大小的语境窗口（例如，此单词之前的5个单词至此单词之后的5个单词） 用上下文中词向量的加权平均(用idf-weighting)来表示每段上下文(当前语境) 。 应用球面k均值算法对第二步中的结果进行聚类。 最后，每一次的单词出现都被重新标签成它所属的类，并且针对这个类，来训练相对应的词向量 当然文集量越大，精度越高 ,这是因为，例子越多，生成的系统学习到的经验就更丰富。比如在完成词汇类比的例子中，系统如果之前没有接触测试词，就可能会生成错误的结果 算法参数的影响:主要影响模型的参数是:语言模型(skip-gram,cbow),窗口大小,向量维度,negative,min-cout等,推荐设置的大小参考参数介绍的内容 训练速度的影响因素:lword2vec 影响速度的因素：语言模型(cbow更快)、迭代次数、线程数等 关于词向量相关评测的论文:Analogical Reasoning on Chinese Morphological and Semantic Relations 2018 ACL,项目链接：https://github.com/Embedding/Chinese-Word-Vectors 该项目提供使用不同表征（稀疏和密集）、上下文特征（单词、n-gram、字符等）以及语料库训练的中文词向量（嵌入）。在这里，你可以轻松获得具有不同属性的预训练向量，并将它们用于各类下游任务。 此外，开发者还在该工具中提供了一个中文类比推理数据集 CA8 及其评估工具包，用户可以以此评估自己词向量的质量。 参数设置如下: 百度百科数据,评测不同表征（稀疏和密集）、上下文特征（单词、n-gram、字符等）的结果: SNGS模型,不同数据的影响: 最新研究 FastText 模型如下: fastText 模型输入一个词的序列（一段文本或者一句话)，输出这个词序列属于不同类别的概率。 序列中的词和词组组成特征向量，特征向量通过线性变换映射到中间层，中间层再映射到标签。 fastText 在预测标签时使用了非线性激活函数，但在中间层不使用非线性激活函数。 fastText 模型架构和 Word2Vec 中的 CBOW 模型很类似。不同之处在于，fastText 预测标签，而 CBOW 模型预测中间词 fastText和word2vec CBOW的区别与联系: 目的: Fasttext-文本整段输入来预测分类(没有窗口的概念) Word2vec-上下文来预测中间词 监督or无监督: Fasttext是有监督-需要人工分类打标 word2vec无监督-不需要打标 输入: Fasttext 没有one-hot,直接是embedded,同时采用了n-gram 加速训练方法和word2vec类似,都用了层次softmax和负采样 fastText词向量的优势 速度快:适合大型数据+高效的训练速度：能够训练模型“在使用标准多核CPU的情况下10分钟内处理超过10亿个词汇”，特别是与深度模型对比，fastText能将训练时间由数天缩短到几秒钟 加入了n-gram特征,利用了语言形态结构 ,使得在用于像捷克语这样词态丰富的语言时，这种方式表现得非常好 比word2vec更考虑了相似性，比如 fastText 的词嵌入学习能够考虑 english-born 和 british-born 之间有相同的后缀，但 word2vec 却不能 fastText专注于文本分类，在许多标准问题上实现当下最好的表现 Glove glove模型背景:考虑到Cbow/Skip-Gram 是一个local context window的方法，比如使用NS来训练，缺乏了整体的词和词的关系，负样本采用sample的方式会缺失词的关系信息。 另外，直接训练Skip-Gram类型的算法，很容易使得高曝光词汇得到过多的权重。 Global Vector融合了矩阵分解Latent Semantic Analysis (LSA)的全局统计信息和local context window优势。融入全局的先验统计信息，可以加快模型的训练速度，又可以控制词的相对权重。 模型目标：进行词的向量化表示，使得向量之间尽可能多地蕴含语义和语法的信息。输入：语料库输出：词向量方法概述：首先基于语料库构建词的共现矩阵，然后基于共现矩阵和GloVe模型学习词向量。 开始 -&gt; 统计共现矩阵 -&gt; 训练词向量 -&gt; 结束 GloVe在多义词方面表现出色 WordRank: Learning Word Embeddings via Robust WordRank使用它们词向量的内积对他们之间的关系建模，内积和他们之间的关系是直接成比例的，如果该词和上下文越相关，内积就会越大 .WordRank在语义类比任务上效果最优,论文中提供了对比结果 词向量的应用 计算item之间的相关性,item包括用户,商品,文本等 词的特征扩充 在term weight 里很有用 作为其它如火如荼的cnn rnn rnn-lstm 系列的初始化输入特征word2vec 算这里面最好的成果了，模型简单，效率高，易调参 参考资料 Word2vec中的数学原理详解 斯坦福cs224d Lecture 2 词向量评价 gensim word2vec 刘建平词向量系列博客 Chinese Word Vectors 中文词向量github]]></content>
  </entry>
  <entry>
    <title><![CDATA[scala]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2Fscala</url>
    <content type="text"><![CDATA[Scala教程Scala简介一门多范式的编程语言（什么叫多范式？可以参考CSDN多范式编程语言 ，综合考虑了面向对象、函数式、泛型编程（例如C++中的模板）），Scala 运行在Java虚拟机上，并兼容现有的Java程序。Scala 源代码被编译成Java字节码，所以它可以运行于JVM之上，并可以调用现有的Java类库，Scala具有如下特性： 面向对象特性 函数式编程 静态类型 扩展性 并发性 Scala安装scala是基于java的，所以需要安装jdk1.5以上版本的。然后安装scala,IDE使用idea，注意配置环境变量（path和classpath） Scala基础语法Scala和java很相似，最大的区别是：Scala 语句末尾的分号 ; 是可选的（python是以缩进取代分号）。与java类似，scala也有类，对象，方法，实例变量的概念，但是与java有点不一样（具体难以用语言描述），类是对象的抽象，而对象是类的具体实例，字段 - 每个对象都有它唯一的实例变量集合，即字段。对象的属性通过给字段赋值来创建。（如何理解字段？） 基本语法：区分大小写；程序文件名 - 程序文件的名称应该与对象名称完全匹配(新版本不需要了，但建议保留这种习惯)。保存文件时，应该保存它使用的对象名称（记住Scala是区分大小写），并追加”.scala”为文件扩展名。 （如果文件名和对象名称不匹配，程序将无法编译）；def main(args: Array[String]) - Scala程序从main()方法开始处理，这是每一个Scala程序的强制程序入口部分；类名格式：示例：class MyFirstScalaClass ；方法名格式：示例：def myMethodName() 标识符：可分为如下几种： 字符数字：字符数字使用字母或是下划线开头，后面可以接字母或是数字，符号”\$”在 Scala 中也看作为字母，然而以”\$”开头的标识符为保留的 Scala 编译器产生的标志符使用，应用程序应该避免使用”\$”开始的标识符，以免造成冲突。 符号:Scala 内部实现时会使用转义的标志符，比如:-&gt; 使用 \$colon$\$colon$minus$greater 混合标识符:混合标志符由字符数字标志符后面跟着一个或多个符号组成，比如 unary_+ 为 Scala 对+方法的内部实现时的名称 字面量标识符:字面量标志符为使用”定义的字符串，比如 `x` `yield`。你可以在”之间使用任何有效的 Scala 标志符 关键字：常用关键字和java类似，其它参考教材 Scala注释：与java类似 Scala包 定义包，很可以使用java或者C#的方式，比如java： 12package com.runoobclass HelloWorld 引用包，使用import,引入包内所以成员：import java.awt._,如果想要引入包中的几个成员，可以使用selector(选取器)： 1234567import java.awt.&#123;Color, Font&#125; // 重命名成员import java.util.&#123;HashMap =&gt; JavaHashMap&#125; // 隐藏成员import java.util.&#123;HashMap =&gt; _, _&#125; // 引入了util包的所有成员，但是HashMap被隐藏了 注意：默认情况下，Scala 总会引入 java.lang._ 、 scala._ 和 Predef._，这里也能解释，为什么以scala开头的包，在使用时都是省去scala.的 Scala数据类型scala的数据类型与python一样，都是对象，除了常见的几个之外还有Unit(等同于c++的void)、Nothing(Nothing类型在Scala的类层级的最低端；它是任何其他类型的子类型)、Any(Any是所有其他类的超类)、Anydef(AnyRef类是Scala里所有引用类(reference class)的基类),另外还需要注意： 多行字符串用三个双引号来表示分隔符，格式为：“”” … “”” 符号字面量被写成： ‘&lt;标识符&gt; ，这里 &lt;标识符&gt; 可以是任何字母或数字的标识（注意：不能以数字开头）。这种字面量被映射成预定义类scala.Symbol的实例。（不知道符号字变量是干什么的） 数据类型定义都是大写 Scala变量变量是一种使用方便的占位符，用于引用计算机内存地址，变量创建后会占用一定的内存空间。基于变量的数据类型，操作系统会进行内存分配并且决定什么将被储存在保留内存中。因此，通过给变量分配不同的数据类型，你可以在这些变量中存储整数，小数或者字母。 变量和常量声明： 在 Scala 中，使用关键词 “var” 声明变量，使用关键词 “val” 声明常量 12var VariableName : DataType [= Initial Value]val VariableName : DataType [= Initial Value] 当然也可以不用指定数据类型，此时会根据初始值推断出数据类型、 多个变量声明： 123val xmax, ymax = 100 // xmax, ymax都声明为100scala&gt; val pa = (40,"Foo")pa: (Int, String) = (40,Foo) //声明元组 Scala访问修饰符Scala 访问修饰符基本和Java的一样，分别有：private，protected，public。如果没有指定访问修饰符符，默认情况下，Scala 对象的访问级别都是 public。Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类甚至不能访问被嵌套类的私有成员。具体如下： private：用 private 关键字修饰，带有此标记的成员仅在包含了成员定义的类或对象内部可见，同样的规则还适用内部类，外部类不能访问内部类的私有成员，但是java可以： 123456789class Outer&#123; class Inner&#123; private def f()&#123;println("f")&#125; class InnerMost&#123; f() // 正确 &#125; &#125; (new Inner).f() //错误&#125; protected：在 scala 中，对保护（Protected）成员的访问比 java 更严格一些。因为它只允许保护成员在定义了该成员的的类的子类中被访问。而在java中，用protected关键字修饰的成员，除了定义了该成员的类的子类可以访问，同一个包里的其他类也可以进行访问 public：Scala中，如果没有指定任何的修饰符，则默认为 public。这样的成员在任何地方都可以被访问 作用域保护：Scala中，访问修饰符可以通过使用限定词强调。格式为: 12private[x] protected[x] 这里的x指代某个所属的包、类或单例对象。如果写成private[x],读作”这个成员除了对[…]中的类或[…]中的包中的类及它们的伴生对像可见外，对其它所有类都是private。这种技巧在横跨了若干包的大型项目中非常有用，它允许你定义一些在你项目的若干子包中可见但对于项目外部的客户却始终不可见的东西。 Scala运算符Scala含有丰富的内置运算符，包括以下几种类型： 算术运算符：与C++一样 关系运算符：与C++一样 逻辑运算符：与C++一样 位运算符：位运算符用来对二进制位进行操作，~,&amp;,|,^分别为取反，按位与与，按位与或，按位与异或运算（把数转换为二进制表示，然后再按位操作），除此之外还有&lt;&lt;（左移）、&gt;&gt;（右移）、&gt;&gt;&gt;（无符号右移）等 赋值运算符：和C++一样，但是没有自加和自减 Scala IF…ELSE语句与C++一模一样 Scala 循环 while循环：与C++一样 do…while循环：类似于c++中的do…until，do…while 循环与 while 循环类似，但是 do…while 循环会确保至少执行一次循环 for 循环：区别有点大，Scala 语言中 for 循环的语法： 123for( var x &lt;- Range )&#123; statement(s);&#125; 以上语法中，Range 可以是一个数字区间表示 i to j （包含j)，或者 i until j(不包含j)。左箭头 &lt;- 用于为变量 x 赋值。 在 for 循环 中你可以使用分号 (;) 来设置多个区间，它将迭代给定区间所有的可能值： 1234567891011object Test &#123; def main(args: Array[String]) &#123; var a = 0; var b = 0; // for 循环 for( a &lt;- 1 to 3; b &lt;- 1 to 3)&#123; //相当于a,b两层嵌套 println( "Value of a: " + a ); println( "Value of b: " + b ); &#125; &#125;&#125; 当然，range也可以是一个集合，for 循环会迭代所有集合的元素。此外还可以实现for 循环过滤,格式如下： 12345for( var x &lt;- List if condition1; if condition2... //满足条件的输出 )&#123; statement(s); &#125; for使用yield,可以将 for 循环的返回值作为一个变量存储。语法格式如下： 123var retVal = for&#123; var x &lt;- List if condition1; if condition2...&#125;yield x 注意大括号中用于保存变量和条件，retVal 是变量， 循环中的 yield 会把当前的元素记下来，保存在集合中，循环结束后将返回该集合 注意： Scala 不支持 break 或 continue 语句，但从 2.8 版本后提供了一种中断循环的方式，格式如下： 123456789101112131415// 导入以下包import scala.util.control._// 创建 Breaks 对象val loop = new Breaks;// 在 breakable 中循环loop.breakable&#123; // 循环 for(...)&#123; .... // 循环中断 loop.break; &#125;&#125; ​ Scala方法和函数Scala 有方法与函数，二者在语义上的区别很小。Scala 方法是类的一部分，而函数是一个对象可以赋值给一个变量。换句话来说在类中定义的函数即是方法.Scala 中的方法跟 Java 的类似，方法是组成类的一部分。Scala 中的函数则是一个完整的对象，Scala 中的函数其实就是继承了 Trait 的类的对象。Scala 中使用 val 语句可以定义函数，def 语句定义方法。可以看scala方法和函数的区别 Scala 方法声明格式如下： 1def functionName ([参数列表]) : [return type] 如果你不写等于号和方法主体，那么方法会被隐式声明为抽象(abstract)，包含它的类型于是也是一个抽象类型。写了就是方法的定义了，方法的定义如下： 1234def functionName ([参数列表]) : [return type] = &#123; function body return [expr]&#125; 实例： 12345678object add&#123; def addInt( a:Int, b:Int ) : Int = &#123; var sum:Int = 0 sum = a + b return sum &#125;&#125; 方法的调用方式和java类似：如下： 12functionName( 参数列表 )[instance.]functionName( 参数列表 ) //如果方法使用了实例的对象来调用，我们可以使用类似java的格式 (使用 . 号) Scala 也是一种函数式语言，所以函数是 Scala 语言的核心,所以需要学习的比较多 函数传名调用: Scala的解释器在解析函数参数(function arguments)时有两种方式： 传值调用（call-by-value）：先计算参数表达式的值，再应用到函数内部； 传名调用（call-by-name）：将未计算的参数表达式直接应用到函数内部 在进入函数内部前，传值调用方式就已经将参数表达式的值计算完毕，而传名调用是在函数内部进行参数表达式的值计算的。这就造成了一种现象，每次使用传名调用时，解释器都会计算一次表达式的值。 123456789101112131415object Test &#123; def main(args: Array[String]) &#123; delayed(time()); &#125; def time() = &#123; println("获取时间，单位为纳秒") System.nanoTime &#125; def delayed( t: =&gt; Long ) = &#123; println("在 delayed 方法内") println("参数： " + t) t &#125;&#125; ​ 指定函数参数名：一般情况下函数调用参数，就按照函数定义时的参数顺序一个个传递。但是我们也可以通过指定函数参数名，并且不需要按照顺序向函数传递参数 可变参数：Scala 允许你指明函数的最后一个参数可以是重复的，即我们不需要指定函数参数的个数，可以向函数传入可变长度参数列表。Scala 通过在参数的类型之后放一个星号来设置可变参数(可重复的参数)。例如： 123456789101112object Test &#123; def main(args: Array[String]) &#123; printStrings("Runoob", "Scala", "Python"); &#125; def printStrings( args:String* ) = &#123; var i : Int = 0; for( arg &lt;- args )&#123; println("Arg value[" + i + "] = " + arg ); i = i + 1; &#125; &#125;&#125; 递归函数：可以调用自身 默认参数值：跟python是一样的、Scala 可以为函数参数指定默认参数值，使用了默认参数，你在调用函数的过程中可以不需要传递参数，这时函数就会调用它的默认参数值，如果传递了参数，则传递值会取代默认值。 高阶函数：高阶函数（Higher-Order Function）就是操作其他函数的函数。Scala 中允许使用高阶函数, 高阶函数可以使用其他函数作为参数，或者使用函数作为输出结果。以下实例中，apply() 函数使用了另外一个函数 f 和 值 v 作为参数，而函数 f 又调用了参数 v： 123456789101112object Test &#123; def main(args: Array[String]) &#123; println( apply( layout, 10) ) &#125; // 函数 f 和 值 v 作为参数，而函数 f 又调用了参数 v def apply(f: Int =&gt; String, v: Int) = f(v) def layout[A](x: A) = "[" + x.toString() + "]" &#125; 函数嵌套：我们可以在 Scala 函数内定义函数，定义在函数内的函数称之为局部函数 匿名函数： 偏应用函数：Scala 偏应用函数是一种表达式，你不需要提供函数需要的所有参数，只需要提供部分，或不提供所需参数（系统内置函数） 函数柯里化（curring)：柯里化(Currying)指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。 Scala闭包闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。 Scala字符串在 Scala 中，字符串的类型实际上是 Java String，它本身没有 String 类。在 Scala 中，String 是一个不可变的对象，所以该对象不可被修改。这就意味着你如果修改字符串就会产生一个新的字符串对象。 创建一个字符串： 12var greeting = "Hello World!";var greeting:String = "Hello World!"; 我们前面提到过 String 对象是不可变的，如果你需要创建一个可以修改的字符串，可以使用 String Builder 类，如下实例: 12345678object Test &#123; def main(args: Array[String]) &#123; val buf = new StringBuilder; buf += 'a' buf ++= "bcdef" println( "buf is : " + buf.toString ); &#125;&#125; String 类中你可以使用 printf() 方法来格式化字符串并输出，String format() 方法可以返回 String 对象而不是 PrintStream 对象。以下实例演示了 printf() 方法的使用： 1234567891011object Test &#123; def main(args: Array[String]) &#123; var floatVar = 12.456 var intVar = 2000 var stringVar = "菜鸟教程!" var fs = printf("浮点型变量为 " + "%f, 整型变量为 %d, 字符串为 " + " %s", floatVar, intVar, stringVar) println(fs) &#125;&#125; String类中提供的方法可以参考教材，基本上能想到的都有 Scala数组数组声明： 1234var z:Array[String] = new Array[String](3) //申请空间var z = new Array[String](3)z(0) = "Runoob"; z(1) = "Baidu"; z(4/2) = "Google" //赋值var z = Array("Runoob", "Baidu", "Google") //显示声明 处理数组的例子： 12345678910111213141516171819202122232425object Test &#123; def main(args: Array[String]) &#123; var myList = Array(1.9, 2.9, 3.4, 3.5) // 输出所有数组元素 for ( x &lt;- myList ) &#123; println( x ) &#125; // 计算数组所有元素的总和 var total = 0.0; for ( i &lt;- 0 to (myList.length - 1)) &#123; total += myList(i); &#125; println("总和为 " + total); // 查找数组中的最大元素 var max = myList(0); for ( i &lt;- 1 to (myList.length - 1) ) &#123; if (myList(i) &gt; max) max = myList(i); &#125; println("最大值为 " + max); &#125;&#125; 多维数组定义： 1var myMatrix = ofDim[Int](3,3) scala提供很多数组方法，下表中为 Scala 语言中处理数组的重要方法，使用它前我们需要使用 import Array._ 引入包 常见的数组方法有：range函数（与python用法一样），length函数（类似于python len函数），concat函数（连接两个数组）等 Scala CollectionScala提供了一套很好的Collection实现，提供了一些Collection类型的抽象。Scala Collection分为可变的和不可变的集合。可变集合可以在适当的地方被更新或扩展。这意味着你可以修改，添加，移除一个集合的元素。而不可变集合类，相比之下，永远不会改变。不过，你仍然可以模拟添加，移除或更新操作。但是这些操作将在每一种情况下都返回一个新的集合，同时使原来的集合不发生改变。 scala List Scala 列表类似于数组，它们所有元素的类型都相同，但是它们也有所不同：列表是不可变的，值一旦被定义了就不能改变，其次列表 具有递归的结构（也就是链接表结构）而数组不是,LIst声明的几个例子： 123456789101112131415161718192021222324252627282930// 字符串列表val site: List[String] = List("Runoob", "Google", "Baidu")// 整型列表val nums: List[Int] = List(1, 2, 3, 4)// 空列表val empty: List[Nothing] = List()// 二维列表val dim: List[List[Int]] = List( List(1, 0, 0), List(0, 1, 0), List(0, 0, 1) )//构造列表的两个基本单位是 Nil 和 ::,Nil 也可以表示为一个空列表。以上实例也可写成// 字符串列表val site = "Runoob" :: ("Google" :: ("Baidu" :: Nil))// 整型列表val nums = 1 :: (2 :: (3 :: (4 :: Nil)))// 空列表val empty = Nil// 二维列表val dim = (1 :: (0 :: (0 :: Nil))) :: (0 :: (1 :: (0 :: Nil))) :: (0 :: (0 :: (1 :: Nil))) :: Nil scala List有很多操作方法：常见的有head、tail、isEmpty、concat、fill(重复列表中的元素)，reverse等，其他参考教程 scala Set Scala Set(集合)是没有重复的对象集合，所有的元素都是唯一的。Scala 集合分为可变的和不可变的集合。默认情况下，Scala 使用的是不可变集合，如果你想使用可变集合，需要引用scala.collection.mutable.Set 包。默认引用 scala.collection.immutable.Set，不可变集合实例如下： 12345val set = Set(1,2,3)println(set.getClass.getName) // println(set.exists(_ % 2 == 0)) //trueprintln(set.drop(1)) //Set(2,3) 如果需要使用可变集合需要引入 scala.collection.mutable.Set： 1234567891011121314import scala.collection.mutable.Set // 可以在任何地方引入 可变集合val mutableSet = Set(1,2,3)println(mutableSet.getClass.getName) // scala.collection.mutable.HashSetmutableSet.add(4)mutableSet.remove(1)mutableSet += 5mutableSet -= 2println(mutableSet) // Set(5, 3, 4)val another = mutableSet.toSetprintln(another.getClass.getName) // scala.collection.immutable.Set 另外就是一些常用的方法了，包括求交集Set.&amp;，查找最大最小值max，min,concat等 scala Map 参考教程 scala 元组 与列表一样，元组也是不可变的，但与列表不同的是元组可以包含不同类型的元素 scala Option Scala Option(选项)类型用来表示一个值是可选的（有值或无值)。 Option[T] 是一个类型为 T 的可选值的容器： 如果值存在， Option[T] 就是一个 Some[T] ，如果不存在， Option[T] 就是对象 None scala Iterator Scala Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法。迭代器 it 的两个基本操作是 next 和 hasNext。调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。调用 it.hasNext() 用于检测集合中是否还有元素。（这里的集合指的是collection),所以说可以将一个collection传入到Iterator中 Scala类和对象类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。我们可以使用 new 关键字来创建类的对象，实例如下： 12345678910111213141516171819202122import java.io._class Point(xc: Int, yc: Int) &#123; var x: Int = xc var y: Int = yc def move(dx: Int, dy: Int) &#123; x = x + dx y = y + dy println ("x 的坐标点: " + x); println ("y 的坐标点: " + y); &#125;&#125;object Test &#123; def main(args: Array[String]) &#123; val pt = new Point(10, 20); // 移到一个新的位置 pt.move(10, 10); &#125;&#125; scala 继承 单例对象 ​ Scala Trait(特征)Scala Trait(特征) 相当于 Java 的接口，实际上它比接口还功能强大。与接口不同的是，它还可以定义属性和方法的实现。一般情况下Scala的类只能够继承单一父类，但是如果是 Trait(特征) 的话就可以继承多个，从结果来看就是实现了多重继承。Trait(特征) 定义的方式与类类似，但它使用的关键字是 trait，如下所示： 1234trait Equal &#123; def isEqual(x: Any): Boolean def isNotEqual(x: Any): Boolean = !isEqual(x)&#125; 以上Trait(特征)由两个方法组成：isEqual 和 isNotEqual。isEqual 方法没有定义方法的实现，isNotEqual定义了方法的实现。子类继承特征可以实现未被实现的方法。所以其实 Scala Trait(特征)更像 Java 的抽象类(但是java的抽象类不能被多重继承），关于java中抽象和接口的区别可以参考Java抽象类与接口的区别 具体实例： 123456789101112131415161718192021222324trait Equal &#123; def isEqual(x: Any): Boolean def isNotEqual(x: Any): Boolean = !isEqual(x)&#125;class Point(xc: Int, yc: Int) extends Equal &#123; var x: Int = xc var y: Int = yc def isEqual(obj: Any) = obj.isInstanceOf[Point] &amp;&amp; obj.asInstanceOf[Point].x == x&#125;object Test &#123; def main(args: Array[String]) &#123; val p1 = new Point(2, 3) val p2 = new Point(2, 4) val p3 = new Point(3, 3) println(p1.isNotEqual(p2)) println(p1.isNotEqual(p3)) println(p1.isNotEqual(2)) &#125;&#125; 所以： 在Scala中，Trait是一种特殊概念。首先，Trait可以被作为接口来使用，此时Trait与Java的接口非常类似。同时在Trait可以定义抽象方法，其与抽象类中的抽象方法一样，不给出方法的具体实现。注意：类使用extends继承Trait，与Java不同，这里不是implement，在Scala中，无论继承类还是继承Trait都是用extends关键字。 在Scala中，类继承Trait后，必须实现其中的抽象方法，实现时不需要使用override关键字，同时Scala同Java一样，不支持类多继承，但支持多重继承Trait，使用with关键字即可 在Trait中定义具体方法：通俗来讲，就是trait可以包含一些很多类都通用的功能，如打印日志等，在Spark中也使用Trait定义了通用的日志打印方法。也就是说Scala中的Trait不只定义抽象方法，还可以定义具体方法，也有的说法是Trait的功能混入了类 在Trait中定义具体字段：在Scala中，Trait可以定义具体字段，继承Trait的类就自动获取了Trait中定义的类。注意：这里与继承Class不同，如果继承Class获取的字段，实际定义在父类中，而继承Trait获取的字段，就直接添加到了类中 在Trait中可以定义抽象字段，而Trait中的具体方法可以基于抽象字段来编写，但继承Trait的类，则必须覆盖抽象的field，提供具体的值。 特征构造顺序 特征也可以有构造器，由字段的初始化和其他特征体中的语句构成。这些语句在任何混入该特征的对象在构造时都会被执行。构造器的执行顺序如下： 调用超类的构造器； 特征构造器在超类构造器之后、类构造器之前执行； 特征由左到右被构造； 每个特征当中，父特征先被构造； 如果多个特征共有一个父特征，父特征不会被重复构造 所有特征被构造完毕，子类被构造。 构造器的顺序是类的线性化的反向。线性化是描述某个类型的所有超类型的一种技术规格。 关于scala的具体可以参考 scala trait详解 Scala 模式匹配类似与switch…case机制，具体实例如下： 123456789101112131415object Test &#123; def main(args: Array[String]) &#123; println(matchTest("two")) println(matchTest("test")) println(matchTest(1)) println(matchTest(6)) &#125; def matchTest(x: Any): Any = x match &#123; //match 对应 Java 里的 switch，但是写在选择器表达式之后。即： 选择器 match &#123;备选项&#125;,switch(x)&#123;&#125; case 1 =&gt; "one" case "two" =&gt; 2 case y: Int =&gt; "scala.Int" //对应类型模式，用于判断传入的值是否为整型，相比使用isInstanceOf来判断类型，使用模式匹配更好 case _ =&gt; "many" //default，相当于case: &#125;&#125; 使用样例类 使用了case关键字的类定义就是就是样例类(case classes)，样例类是种特殊的类，经过优化以用于模式匹配，例如： 123456789101112131415161718object Test &#123; def main(args: Array[String]) &#123; val alice = new Person("Alice", 25) val bob = new Person("Bob", 32) val charlie = new Person("Charlie", 32) for (person &lt;- List(alice, bob, charlie)) &#123; person match &#123; case Person("Alice", 25) =&gt; println("Hi Alice!") case Person("Bob", 32) =&gt; println("Hi Bob!") case Person(name, age) =&gt; println("Age: " + age + " year, name: " + name + "?") &#125; &#125; &#125; // 样例类 case class Person(name: String, age: Int)&#125; 在声明样例类时，下面的过程自动发生了： 构造器的每个参数都成为val，除非显式被声明为var，但是并不推荐这么做； 在伴生对象中提供了apply方法，所以可以不使用new关键字就可构建对象； 提供unapply方法使模式匹配可以工作； 生成toString、equals、hashCode和copy方法，除非显示给出这些方法的定义。 具体可以参考： 简书scala case class Scala 正则表达式Scala 的正则表达式继承了 Java 的语法规则，Java 则大部分使用了 Perl 语言的规则,Scala 通过 scala.util.matching 包中的 Regex 类来支持正则表达式,以下是一些实例： 123456789101112import scala.util.matching.Regex //在这个包里面object Test &#123; def main(args: Array[String]) &#123; val pattern1 = "Scala".r //String 类的 r() 方法构造了一个Regex对象 val pattern2 = new Regex("(S|s)cala") // 首字母可以是大写 S 或小写 s val str = "Scala is Scalable and cool" println((pattern2 findAllIn str).mkString(",")) // 使用逗号 , 连接返回结果,mkString( ) 方法来连接正则表达式匹配结果的字符串，并可以使用管道(|)来设置不同的模式,如果需要查看所有的匹配项可以使用 findAllIn 方法 println(pattern1 findFirstIn str) //findFirstIn 方法找到首个匹配项, println(pattern2 replaceFirstIn(str, "Java")) //找到第一个匹配项，然后取代 &#125;&#125; Scala异常处理try…catch…finally语句实例： 123456789101112131415161718192021import java.io.FileReaderimport java.io.FileNotFoundExceptionimport java.io.IOException/*异常捕捉的机制与其他语言中一样，如果有异常发生，catch字句是按次序捕捉的。因此，在catch字句中，越具体的异常越要靠前，越普遍的异常越靠后。 如果抛出的异常不在catch字句中，该异常则无法处理，会被升级到调用者处*/object Test &#123; def main(args: Array[String]) &#123; try &#123; val f = new FileReader("input.txt") &#125; catch &#123; case ex: FileNotFoundException =&gt; &#123; println("Missing file exception") &#125; case ex: IOException =&gt; &#123; println("IO Exception") &#125; &#125; finally &#123; println("Exiting finally...") //finally 语句用于执行不管是正常处理还是有异常发生时都需要执行的步骤 &#125; &#125;&#125; Scala 抛出异常的方法和 Java一样，使用 throw 方法，例如，抛出一个新的参数异常： 1throw new IllegalArgumentException Scala 提取器提取器是从传递给它的对象中提取出构造该对象的参数，Scala 提取器是一个带有unapply方法的对象。unapply方法算是apply方法的反向操作：unapply接受一个对象，然后从对象中提取值，提取的值通常是用来构造该对象的值。 Scala 文件I/O 从屏幕读取 1234567object Test &#123; def main(args: Array[String]) &#123; print("请输入菜鸟教程官网 : " ) val line = Console.readLine //从屏幕读取 println("谢谢，你输入的是: " + line) &#125;&#125; 读写文件 写文件 12345678910import java.io._object Test &#123; def main(args: Array[String]) &#123; val writer = new PrintWriter(new File("test.txt" )) writer.write("菜鸟教程") writer.close() &#125;&#125; 读文件 1234567891011import scala.io.Source object Test &#123; def main(args: Array[String]) &#123; println("文件内容为:" ) Source.fromFile("test.txt" ).foreach&#123; //使用 Scala 的 Source 类及伴生对象来读取文件 print &#125; &#125;&#125; Scala注意问题 不要把scala 写成java 或者c++ var 和 val 的区别 trait 是什么? 和class 有什么区别 拒绝for 和while 循环 少写if 少用+连接字符串, 用s”${var1}${var2}”模式 对collection 的 reduce 的用法 有哪些collection? 相互之间关系和区别 Option 是什么?]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
